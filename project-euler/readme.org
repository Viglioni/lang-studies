#+title: Project Euler solutions

In this file I will solve problems from [[https://projecteuler.net/archives][Project Euler]] using Elixir lang.

** Reusable modules
*** Prime module
#+begin_src elixir :exports code :results output 
  defmodule Prime do
    defp ceil_sqrt(n), do: n |> :math.sqrt() |> ceil

    defp possible_factors(n), do: 2..ceil_sqrt(n)

    def divides?(a, b), do: rem(b, a) == 0

    def prime?(2), do: true
    def prime?(n), do: n |> possible_factors |> Enum.filter(&divides?(&1, n)) |> (&(&1 == [])).()

    def primes do
      Stream.concat(2..2, Stream.iterate(3, fn n -> n + 2 end)) |> Stream.filter(&prime?/1)
    end

    def nth_prime(n) do
      primes() |> Stream.drop(n - 1) |> Enum.take(1) |> hd
    end

    def take(n), do: primes() |> Enum.take(n)

    def possible_prime_factors(n) do
      max_val = ceil_sqrt(n)
      primes() |> Stream.take_while(fn el -> el <= max_val end) |> Enum.to_list()
    end
  end
#+end_src

#+RESULTS:
: [33mwarning: [0mredefining module Prime (current version defined in memory)
:   iex:1
: 
: {:module, Prime,
:  <<70, 79, 82, 49, 0, 0, 14, 124, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 1, 195,
:    0, 0, 0, 46, 12, 69, 108, 105, 120, 105, 114, 46, 80, 114, 105, 109, 101, 8,
:    95, 95, 105, 110, 102, 111, 95, 95, 10, ...>>, {:possible_prime_factors, 1}}

*** Number Theory Module
#+begin_src elixir :exports code :results output 
  defmodule NumberTheory do
    def gcd(a, 0), do: a
    def gcd(0, a), do: a

    def gcd(a, b), do: gcd(min(a, b), rem(max(a, b), min(a, b)))

    def lcm(a, b), do: div(a * b, gcd(a, b))
  end
#+end_src

#+RESULTS:
: [33mwarning: [0mredefining module NumberTheory (current version defined in memory)
:   iex:1
: 
: {:module, NumberTheory,
:  <<70, 79, 82, 49, 0, 0, 6, 240, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 185,
:    0, 0, 0, 21, 19, 69, 108, 105, 120, 105, 114, 46, 78, 117, 109, 98, 101, 114,
:    84, 104, 101, 111, 114, 121, 8, 95, 95, ...>>, {:lcm, 2}}



** Problem 1
*Find the sum of all the multiples of 3 or 5 below 1000.*

#+begin_src elixir :exports both :results output 
  multiple_of_3_or_5 = fn n -> rem(n, 5) * rem(n, 3) == 0 end
  1..999 |> Enum.filter(multiple_of_3_or_5) |> Enum.sum()
#+end_src

#+RESULTS:
: 233168

** Problem 2

*By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.*

#+begin_src elixir :exports both :results output 
  require Integer

  defmodule Ex2 do
    @limit 4_000_000

    defp fib(list) do
      curr = list |> Enum.take(2) |> Enum.sum()

      if curr < @limit do
        fib([curr | list])
      else
        list
      end
    end

    defp even?(x), do: rem(x, 2) == 0

    def fib_even_sum() do
      [1, 1] |> fib |> Enum.filter(&even?/1) |> Enum.sum()
    end
  end

  Ex2.fib_even_sum()
#+end_src

#+RESULTS:
: 4613732

** Problem 3

*What is the largest prime factor of the number 600851475143?*

#+begin_src elixir :exports both :results output 
  largest_prime_factor = fn n ->
    n
    |> Prime.possible_prime_factors()
    |> Enum.filter(&Prime.divides?(&1, n))
    |> List.last()
  end

  largest_prime_factor.(600_851_475_143)
#+end_src

#+RESULTS:
: 6857

** Problem 4

*Find the largest palindrome made from the product of two 3-digit numbers.*

#+begin_src elixir :exports both :results output 
  palindrome? = fn n ->
    str = Integer.to_string(n)
    str == String.reverse(str)
  end

  numbers = 999..100

  Stream.zip_with(numbers, numbers, &(&1 * &2)) |> Stream.filter(palindrome?) |> Enum.take(1) |> hd

#+end_src

#+RESULTS:
: 698896

** Problem 5
*What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?*

#+begin_src elixir :exports both :results output 
  1..20 |> Enum.reduce(1, &NumberTheory.lcm/2)
#+end_src

#+RESULTS:
: 232792560

** Problem 6
*Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.*

#+begin_src elixir :exports both :results output 
  square_of_the_sum = fn n -> div(n * (n + 1), 2) ** 2 end

  sum_of_the_squares = fn n -> div(n * (n + 1) * (2 * n + 1), 6) end

  square_of_the_sum.(100) - sum_of_the_squares.(100)
#+end_src

#+RESULTS:
: 25164150

** Problem 7
*What is the 10 001st prime number?*

#+begin_src elixir :exports both :results output 
  Prime.nth_prime 10_001
#+end_src

#+RESULTS:
: 104743

** Problem 8

*Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?*

#+begin_src elixir :exports both :results output 
  number = 7_316_717_653_133_062_491_922_511_967_442_657_474_235_534_919_493_496_983_520_312_774_506_326_239_578_318_016_984_801_869_478_851_843_858_615_607_891_129_494_954_595_017_379_583_319_528_532_088_055_111_254_069_874_715_852_386_305_071_569_329_096_329_522_744_304_355_766_896_648_950_445_244_523_161_731_856_403_098_711_121_722_383_113_622_298_934_233_803_081_353_362_766_142_828_064_444_866_452_387_493_035_890_729_629_049_156_044_077_239_071_381_051_585_930_796_086_670_172_427_121_883_998_797_908_792_274_921_901_699_720_888_093_776_657_273_330_010_533_678_812_202_354_218_097_512_545_405_947_522_435_258_490_771_167_055_601_360_483_958_644_670_632_441_572_215_539_753_697_817_977_846_174_064_955_149_290_862_569_321_978_468_622_482_839_722_413_756_570_560_574_902_614_079_729_686_524_145_351_004_748_216_637_048_440_319_989_000_889_524_345_065_854_122_758_866_688_116_427_171_479_924_442_928_230_863_465_674_813_919_123_162_824_586_178_664_583_591_245_665_294_765_456_828_489_128_831_426_076_900_422_421_902_267_105_562_632_111_110_937_054_421_750_694_165_896_040_807_198_403_850_962_455_444_362_981_230_987_879_927_244_284_909_188_845_801_561_660_979_191_338_754_992_005_240_636_899_125_607_176_060_588_611_646_710_940_507_754_100_225_698_315_520_005_593_572_972_571_636_269_561_882_670_428_252_483_600_823_257_530_420_752_963_450

  fst = fn {a, _} -> a end
  snd = fn {_, a} -> a end

  split_integer = fn n ->
    n |> Integer.to_string() |> String.split("", trim: true) |> Enum.map(&String.to_integer/1)
  end

  number_list = number |> split_integer.()

  el_mul = fn idx ->
    Enum.drop(number_list, idx) |> Enum.take(13) |> (&{&1, Enum.product(&1)}).()
  end

  0..999 |> Enum.map(el_mul) |> Enum.max(fn a, b -> snd.(a) > snd.(b) end)
#+end_src

#+RESULTS:
: {[5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5], 23514624000}

